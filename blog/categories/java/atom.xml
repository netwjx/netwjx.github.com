<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[类别: Java | netwjx's Blog]]></title>
  <link href="http://netwjx.github.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://netwjx.github.com/"/>
  <updated>2012-05-01T22:28:41+08:00</updated>
  <id>http://netwjx.github.com/</id>
  <author>
    <name><![CDATA[netwjx]]></name>
    <email><![CDATA[netwjx@mail.com]]></email>
    <uri>http://netwjx.github.com/</uri>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>
  <icon>/favicon.png</icon>
  <subtitle><![CDATA[混乱与有序]]></subtitle>

  
  <entry>
    <title type="html"><![CDATA[截取指定字节长度的字符串]]></title>
    
      <category term="Java" />
    
    <link href="http://netwjx.github.com/blog/2012/04/15/substring-with-bytes-length/"/>
    <author>
      <name><![CDATA[netwjx]]></name>
      <uri>http://netwjx.github.com/</uri>
    </author>
    <published>2012-04-15T18:35:00+08:00</published>
    <updated>2012-04-15T18:35:00+08:00</updated>
    <id>http://netwjx.github.com/blog/2012/04/15/substring-with-bytes-length</id>
    <content type="html"><![CDATA[<p>在搜文本换行算法的时候发现了<a href="http://www.iteye.com/topic/1037773">编写一个截取字符串的函数</a>, 问题是</p>

<blockquote><p>编写一个截取字符串的函数，输入为一个<strong>字符串</strong>和<strong>字节数</strong>，输出为<strong>按字节截取的字符串</strong>。</p>

<p>但是要保证汉字<strong>不被截半个</strong>，如“我ABC”4，应该截为“我AB”，输入“我ABC汉DEF”，6，应该输出为“我ABC”而不是“我ABC+汉的半个”。</p></blockquote>

<p>可能描述的有些不明确, 应该这样说</p>

<blockquote><p>编写一个截取字符串的函数, 给定<strong>字符串</strong>, <strong>编码格式</strong>, 使用前2个参数编码之后的<strong>字节数组</strong>, 以及截取<strong>字节数组的最大长度</strong>.</p>

<p>要求返回<strong>实际需要截取的长度</strong>, 不能在解码指定长度字节数组后出现<strong>半个字符</strong>的现象.</p></blockquote>

<p>那么测试代码大概是这样的(就以Java为例):</p>

<p>``` java
  String str = "我abc的def";
  String charset = "gbk";
  int length = 6;
  byte[] bytes = str.getBytes(charset);</p>

<p>  String result = new String(bytes, 0, subString(str, charset, bytes,</p>

<pre><code>  length), charset);
</code></pre>

<p>  assert result.equals("我abc的");
```</p>

<p>最后一行的断言仅适用于gbk和utf-8的情况, 其它的不保证可用.</p>

<p>在开始的帖子中看到过一个实现, 等价于下面的代码:</p>

<p>``` java
  private static int subString(String str, String charset, byte[] bytes,</p>

<pre><code>  int length) throws UnsupportedEncodingException {
int i = 0;
for (char c : str.toCharArray()) {
  int n = i + String.valueOf(c).getBytes(charset).length;
  if (n &gt; length)
    return i;
  else if (n == length)
    return n;
  i = n;
}
return i;
</code></pre>

<p>  }
```</p>

<p>不过想想, subString返回值一般在length-3到length之间, 可以探测截取指定长度是否会有问题, 那么就可以有下面的一个实现:</p>

<p>``` java
  private static int detectByte(String str, String charset, byte[] bytes,</p>

<pre><code>  int length) throws UnsupportedEncodingException {
String s = null;
int i = length + 1;
do {
  i--;
  s = new String(bytes, 0, i, charset);
} while (!str.substring(0, s.length()).equals(s));
return i;
</code></pre>

<p>  }
```</p>

<p>再想想, 实际有差别的只是最后一个字符, 只比较最后一个字符即可:</p>

<p>``` java
  private static int subString(String str, String charset, byte[] bytes,</p>

<pre><code>  int length) throws UnsupportedEncodingException {
String s = null;
int n = length + 1;
int i;
do {
  n--;
  s = new String(bytes, 0, n, charset);
  i = s.length() - 1;
} while (str.charAt(i) != s.charAt(i));
return n;
</code></pre>

<p>  }
```</p>

<p>第一种会比较慢些, 后面的方法会占用更多的内存.</p>

<p>这个问题始终和编码类型有关的, 因为需要返回的是字节数组/流的长度, 而不是字符数组/串/流的长度.</p>

<p>不过这个代码的应用场景我还是想不出来, 即使有这样的场景, 也可以有别的变通办法可以不需要这样截取.</p>

      <p><a href="http://netwjx.github.com/blog/2012/04/15/substring-with-bytes-length/#comments">查看评论</a></p>]]></content>
  </entry>
  
</feed>
