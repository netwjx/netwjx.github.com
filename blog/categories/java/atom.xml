<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[类别: Java | netwjx's Blog]]></title>
  <link href="http://netwjx.github.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://netwjx.github.com/"/>
  <updated>2012-04-15T21:29:27+08:00</updated>
  <id>http://netwjx.github.com/</id>
  <author>
    <name><![CDATA[netwjx]]></name>
    <email><![CDATA[netwjx@mail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[截取指定字节长度的字符串]]></title>
    <link href="http://netwjx.github.com/blog/2012/04/15/substring-with-bytes-length/"/>
    <updated>2012-04-15T18:35:00+08:00</updated>
    <id>http://netwjx.github.com/blog/2012/04/15/substring-with-bytes-length</id>
    <content type="html"><![CDATA[<p>在搜文本换行算法的时候发现了 <a href="http://www.iteye.com/topic/1037773">这个</a>, 问题是</p>

<blockquote><p>编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串。 但是要保证汉字不被截半个，如“我ABC”4，应该截为“我AB”，输入“我ABC汉DEF”，6，应该输出为“我ABC”而不是“我ABC+汉的半个”。</p></blockquote>

<p>可能描述的有些不明确, 应该这样说</p>

<blockquote><p>编写一个截取字符串的函数, 给定字符串, 编码格式, 这个字符串使用指定编码后的字节数组, 以及需要截取的字节数组最大长度
要求返回实际需要截取的长度, 不能在解码指定长度字节数组后出现半个字符的现象.</p></blockquote>

<p>那么测试代码大概是这样的(就以Java为例):</p>

<p>``` java
  String str = "我abc的def";
  String charset = "gbk";
  int length = 6;
  byte[] bytes = str.getBytes(charset);</p>

<p>  String result = new String(bytes, 0, subString(str, charset, bytes,</p>

<pre><code>  length), charset);
</code></pre>

<p>  assert result.equals("我abc的");
```</p>

<p>下面的断言仅适用于gbk和utf-8的情况, 其它的不保证可用.</p>

<p>在开始的帖子中看到过一个实现, 等价于下面:</p>

<p>``` java
  private static int subString(String str, String charset, byte[] bytes,</p>

<pre><code>  int length) throws UnsupportedEncodingException {
int i = 0;
for (char c : str.toCharArray()) {
  int n = i + String.valueOf(c).getBytes(charset).length;
  if (n &gt; length)
    return i;
  else if (n == length)
    return n;
  i = n;
}
return i;
</code></pre>

<p>  }
```</p>

<p>不过想想, subString返回值一般在length-3到length之间, 可以探测截取指定长度是否会有问题, 那么就可以有下面的一个实现:</p>

<p>``` java
  private static int detectByte(String str, String charset, byte[] bytes,</p>

<pre><code>  int length) throws UnsupportedEncodingException {
String s = null;
int i = length + 1;
do {
  i--;
  s = new String(bytes, 0, i, charset);
} while (!str.substring(0, s.length()).equals(s));
return i;
</code></pre>

<p>  }
```</p>

<p>再想想, 实际有差别的只是最后一个字符, 只比较最后一个字符即可:</p>

<p>``` java
  private static int subString(String str, String charset, byte[] bytes,</p>

<pre><code>  int length) throws UnsupportedEncodingException {
String s = null;
int n = length + 1;
int i;
do {
  n--;
  s = new String(bytes, 0, n, charset);
  i = s.length() - 1;
} while (str.charAt(i) != s.charAt(i));
return n;
</code></pre>

<p>  }
```</p>

<p>第一种会比较慢些, 后面的方法会占用更多的内存.</p>

<p>不过这个代码的应用场景我还是想不出来, 即使有这样的场景, 也可以有别的变通办法可以不需要这样截取</p>
]]></content>
  </entry>
  
</feed>
